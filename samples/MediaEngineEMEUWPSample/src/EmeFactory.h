// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#pragma once

inline std::string ToString(MF_MEDIAKEYSESSION_TYPE Value)
{
    static std::pair<MF_MEDIAKEYSESSION_TYPE, char const*> constexpr const g_MessageTypes[]
    {
        #define IDENFITIER(Name) std::make_pair(Name, #Name),
        IDENFITIER(MF_MEDIAKEYSESSION_TYPE_TEMPORARY)
        IDENFITIER(MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE)
        IDENFITIER(MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE)
        IDENFITIER(MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD)
        #undef IDENFITIER
    };
    return ToString(g_MessageTypes, Value);
}

inline std::string ToString(MF_MEDIAKEY_STATUS Value)
{
    static std::pair<MF_MEDIAKEY_STATUS, char const*> constexpr const g_MessageTypes[]
    {
        #define IDENFITIER(Name) std::make_pair(Name, #Name),
        IDENFITIER(MF_MEDIAKEY_STATUS_USABLE)
        IDENFITIER(MF_MEDIAKEY_STATUS_EXPIRED)
        IDENFITIER(MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED)
        IDENFITIER(MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED)
        IDENFITIER(MF_MEDIAKEY_STATUS_STATUS_PENDING)
        IDENFITIER(MF_MEDIAKEY_STATUS_INTERNAL_ERROR)
        IDENFITIER(MF_MEDIAKEY_STATUS_RELEASED)
        IDENFITIER(MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED)
        #undef IDENFITIER
    };
    return ToString(g_MessageTypes, Value);
}

// MFMediaKeyStatus

inline std::string ToString(MF_MEDIAKEYSESSION_MESSAGETYPE Value)
{
    static std::pair<MF_MEDIAKEYSESSION_MESSAGETYPE, char const*> constexpr const g_MessageTypes[]
    {
        #define IDENFITIER(Name) std::make_pair(Name, #Name),
        IDENFITIER(MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST)
        IDENFITIER(MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL)
        IDENFITIER(MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE)
        IDENFITIER(MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST)
        #undef IDENFITIER
    };
    return ToString(g_MessageTypes, Value);
}

// MF_CROSS_ORIGIN_POLICY

namespace media {
namespace eme {

// Based on the MediaKeySession interface in the EME specification:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession
class MediaKeySession
{
public:
    MediaKeySession(wil::com_ptr<IMFContentDecryptionModule> const& ContentDecryptionModule, MF_MEDIAKEYSESSION_TYPE SessionType)
    {
        WI_ASSERT(ContentDecryptionModule);
        auto const OnKeyMessage = [&] (MF_MEDIAKEYSESSION_MESSAGETYPE messageType, gsl::span<uint8_t> message, LPCWSTR destinationUrl) { m_keyMessageCB(messageType, message, destinationUrl); };
        auto const OnKeyStatusChanged = [&] () { m_keyStatusChangedCB(); };
        m_sessionCallbacks = winrt::make_self<SessionCallbackHelper>(OnKeyMessage, OnKeyStatusChanged);
        TRACE(L"Before IMFContentDecryptionModule::CreateSession, this %p, SessionType %hs\n", this, ToString(SessionType).c_str());
        THROW_IF_FAILED(ContentDecryptionModule->CreateSession(SessionType, m_sessionCallbacks.get(), m_cdmSession.put()));
        TRACE(L"this %p, IMFContentDecryptionModuleSession m_cdmSession %p\n", this, m_cdmSession.get());
    }
    virtual ~MediaKeySession()
    {
        static_cast<SessionCallbackHelper*>(m_sessionCallbacks.get())->DetachParent();
    }

    // A unique string identifier generated by the CDM that can be used by the application
    // to identify session objects.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-sessionid
    wil::unique_cotaskmem_string sessionId() const
    {
        wil::unique_cotaskmem_string Result;
        THROW_IF_FAILED(m_cdmSession->GetSessionId(Result.put()));
        TRACE(L"After IMFContentDecryptionModule::GetSessionId, this %p, Result %ls\n", this, Result.get());
        return Result;
    }

    // The expiration time for all key(s) in the session, or NaN if no such time exists or
    // if the license explicitly never expires, as determined by the CDM.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-expiration
    // expiration is based on https://tc39.es/ecma262/#sec-time-values-and-time-range
    double expiration() const
    {
        double Result = 0.0;
        THROW_IF_FAILED(m_cdmSession->GetExpiration(&Result));
        TRACE(L"After IMFContentDecryptionModule::GetExpiration, this %p, Result %.3f\n", this, Result);
        return Result;
    }

    using MediaKeyStatusPair = std::tuple<std::vector<uint8_t>, MF_MEDIAKEY_STATUS>;
    // A reference to an array of key IDs known to the session to the current status
    // of the associated key. Each entry MUST have a unique key ID.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-keystatuses
    std::vector<MediaKeyStatusPair> keyStatuses() const
    {
        wil::unique_cotaskmem_array_ptr<MFMediaKeyStatus> abiKeyStatuses;
        THROW_IF_FAILED(m_cdmSession->GetKeyStatuses(abiKeyStatuses.put(), abiKeyStatuses.size_address<UINT>()));
        TRACE(L"After IMFContentDecryptionModule::GetKeyStatuses, this %p, abiKeyStatuses.size() %zu\n", this, abiKeyStatuses.size());
        std::vector<MediaKeyStatusPair> statusPairs(abiKeyStatuses.size());
        for(size_t i = 0; i < abiKeyStatuses.size(); i++)
        {
            std::vector<uint8_t> keyId(abiKeyStatuses[i].cbKeyId);
            memcpy(&keyId[0], abiKeyStatuses[i].pbKeyId, keyId.size());
            statusPairs[i] = std::make_tuple(std::move(keyId), abiKeyStatuses[i].eMediaKeyStatus);
        }
        return statusPairs;
    }

    // Loads the data stored for the specified session into this object.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-load
    bool load(const std::wstring& SessionIdentifier) const
    {
        BOOL Result = FALSE;
        THROW_IF_FAILED(m_cdmSession->Load(SessionIdentifier.c_str(), &Result));
        TRACE(L"After IMFContentDecryptionModule::Load, this %p, SessionIdentifier %ls, Result %d\n", this, SessionIdentifier.c_str(), Result);
        return !!Result;
    }

    // Callback registration methods
    using KeyMessageCB = std::function<void(MF_MEDIAKEYSESSION_MESSAGETYPE, gsl::span<uint8_t>, LPCWSTR)>;
    void onmessage(KeyMessageCB&& keyMessageCB)
    {
        m_keyMessageCB = std::move(keyMessageCB);
    }

    using KeyStatusChangedCB = std::function<void()>;
    void onkeystatuseschange(KeyStatusChangedCB&& keyStatusChangedCB)
    {
        m_keyStatusChangedCB = std::move(keyStatusChangedCB);
    }
    
    // Generates a license request based on the InitializationData. A message of type "license-request" or
    // "individualization-request" will always be queued if the algorithm succeeds
    // and the promise is resolved.
    // Structure for init data is based on InitializationDataType
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-generaterequest
    // https://www.w3.org/TR/eme-initdata-registry/
    void generateRequest(const std::wstring& InitializationDataType, std::vector<uint8_t> const& InitializationData)
    {
        TRACE(L"Before IMFContentDecryptionModule::GenerateRequest, this %p, InitializationDataType %ls, InitializationData %zu\n", this, InitializationDataType.c_str(), InitializationData.size());
        THROW_IF_FAILED(m_cdmSession->GenerateRequest(InitializationDataType.c_str(), InitializationData.data(), static_cast<DWORD>(InitializationData.size())));
    }

    // Provides messages, including licenses, to the CDM.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-update
    void update(gsl::span<uint8_t> ResponseData)
    {
        TRACE(L"Before IMFContentDecryptionModule::Update, this %p, ResponseData %zu\n", this, ResponseData.size());
        THROW_IF_FAILED(m_cdmSession->Update(ResponseData.data(), static_cast<DWORD>(ResponseData.size())));
    }

    // Indicates that the application no longer needs the session and the CDM should release any resources
    // associated with the session and close it. Persisted data should not be released or cleared.
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-close
    void close()
    {
        TRACE(L"Before IMFContentDecryptionModule::Close, this %p\n", this);
        THROW_IF_FAILED(m_cdmSession->Close());
    }

    // Removes all license(s) and key(s) associated with the session. For persistent session types,
    // other session data will be cleared as defined for each session type once a
    // release message acknowledgment is processed by Update().
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysession-remove
    void remove()
    {
        TRACE(L"Before IMFContentDecryptionModule::Remove, this %p\n", this);
        THROW_IF_FAILED(m_cdmSession->Remove());
    }

private:

    class SessionCallbackHelper : public winrt::implements<SessionCallbackHelper, IMFContentDecryptionModuleSessionCallbacks>
    {
    public:
        SessionCallbackHelper(MediaKeySession::KeyMessageCB&& keyMessageCB, MediaKeySession::KeyStatusChangedCB&& keyStatusChangedCB) : 
            m_keyMessageCB(std::move(keyMessageCB)), 
            m_keyStatusChangedCB(std::move(keyStatusChangedCB))
        {
            THROW_HR_IF(E_INVALIDARG, !m_keyMessageCB);
            THROW_HR_IF(E_INVALIDARG, !m_keyStatusChangedCB);
        }
        ~SessionCallbackHelper()
        {
            DetachParent();
        }

        void DetachParent()
        {
            auto lock = m_lock.lock();
            m_keyMessageCB = nullptr;
            m_keyStatusChangedCB = nullptr;
        }

    // IMFContentDecryptionModuleSessionCallbacks
        IFACEMETHOD(KeyMessage)(MF_MEDIAKEYSESSION_MESSAGETYPE Type, const BYTE* Data, DWORD DataSize, LPCWSTR Location) noexcept override
        {
            TRACE(L"this %p, Type %hs, DataSize %u, Location \"%ls\"\n", this, ToString(Type).c_str(), DataSize, Location);
            try
            {
                auto lock = m_lock.lock();
                m_keyMessageCB(Type, gsl::span<uint8_t>(const_cast<BYTE*>(Data), static_cast<size_t>(DataSize)), Location);
            }
            CATCH_RETURN();
            return S_OK;
        }
        IFACEMETHOD(KeyStatusChanged)() noexcept override
        {
            TRACE(L"this %p\n", this);
            try
            {
                auto lock = m_lock.lock();
                m_keyStatusChangedCB();
            }
            CATCH_RETURN();
            return S_OK;
        }

    private:
        wil::critical_section m_lock;
        MediaKeySession::KeyMessageCB m_keyMessageCB;
        MediaKeySession::KeyStatusChangedCB m_keyStatusChangedCB;
    };

    wil::com_ptr<IMFContentDecryptionModuleSession> m_cdmSession;
    winrt::com_ptr<SessionCallbackHelper> m_sessionCallbacks;
    KeyMessageCB m_keyMessageCB;
    KeyStatusChangedCB m_keyStatusChangedCB;
};

// Based on the MediaKeys interface in the EME specification:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeys
class MediaKeys
{
public:
    MediaKeys(wil::com_ptr<IMFContentDecryptionModule> const& ContentDecryptionModule) :
        m_ContentDecryptionModule(ContentDecryptionModule)
    {
    }

    std::shared_ptr<MediaKeySession> createSession(MF_MEDIAKEYSESSION_TYPE sessionType = MF_MEDIAKEYSESSION_TYPE_TEMPORARY)
    {
        return std::make_shared<MediaKeySession>(m_ContentDecryptionModule, sessionType);
    }
    //bool SetServerCertificate(std::vector<uint8_t>& ServerCertificate)
    //{
    //    return SUCCEEDED(m_ContentDecryptionModule->SetServerCertificate(ServerCertificate.data(), static_cast<DWORD>(ServerCertificate.size())));
    //}

    wil::com_ptr<IMFContentDecryptionModule> const m_ContentDecryptionModule;
};

// This struct represents a MediaKeySystemMediaCapability dictionary, as defined in the EME specification:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-mediakeysystemmediacapability
struct MediaKeySystemMediaCapability
{
    std::wstring contentType;
    std::wstring robustness;
};

struct EmeFactoryConfiguration
{
    static void SetPropertyValue(wil::com_ptr<IPropertyStore> const& PropertyStore, PROPERTYKEY const& Key, std::wstring const& Value)
    {
        wil::unique_prop_variant VariantValue;
        VariantValue.vt = VT_BSTR;
        VariantValue.bstrVal = wil::make_bstr(Value.c_str()).release();
        THROW_IF_FAILED(PropertyStore->SetValue(Key, VariantValue));
    }

    wil::com_ptr<IPropertyStore> ConvertToPropertyStore() const
    {
        wil::com_ptr<IPropertyStore> PropertyStore;
        THROW_IF_FAILED(PSCreateMemoryPropertyStore(IID_PPV_ARGS(PropertyStore.put())));
        SetPropertyValue(PropertyStore, MF_EME_CDM_STOREPATH, storagePath);
        if(!inPrivateStoragePath.empty())
            SetPropertyValue(PropertyStore, MF_EME_CDM_INPRIVATESTOREPATH, inPrivateStoragePath);
        return PropertyStore;
    }

    // Use this property to pass a storage location the CDM can use for initialization.
    // This storage location will also be used for content specific data if INPRIVATESTOREPATH is not set.
    // The app should not delete the store location to optimize performance of the CDM.
    std::wstring storagePath;
    // Use this property to pass a storage location the CDM can use for content specific data (e.g licenses)
    // The app should delete the store location after the CDM object has been released.
    std::wstring inPrivateStoragePath;
};

// This class represents a MediaKeySystemConfiguration dictionary, as defined in the EME specification:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#mediakeysystemconfiguration-dictionary
class MediaKeySystemConfiguration
{
public:
    static MediaKeySystemConfiguration FromPropertyStore(wil::com_ptr<IPropertyStore> const& propertyStore)
    {
        MediaKeySystemConfiguration configuration;
    
        // Init data types
        wil::unique_prop_variant initDataTypes;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_INITDATATYPES, &initDataTypes)) &&
           initDataTypes.vt == (VT_VECTOR | VT_BSTR))
        {
            configuration.m_initDataTypes.resize(initDataTypes.cabstr.cElems);
            for(size_t i = 0; i < initDataTypes.cabstr.cElems; i++)
            {
                configuration.m_initDataTypes[i] = std::wstring(initDataTypes.cabstr.pElems[i]);
            }
        }

        // Audio capabilities
        wil::unique_prop_variant audioCapabilities;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_AUDIOCAPABILITIES, &audioCapabilities)) &&
           audioCapabilities.vt == (VT_VECTOR | VT_VARIANT))
        {
            GetCapabilitiesFromPropVar(audioCapabilities, configuration.m_audioCapabilities);
        }

        // Video capabilities
        wil::unique_prop_variant videoCapabilities;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_VIDEOCAPABILITIES, &videoCapabilities)) &&
           videoCapabilities.vt == (VT_VECTOR | VT_VARIANT))
        {
            GetCapabilitiesFromPropVar(videoCapabilities, configuration.m_videoCapabilities);
        }

        // Distinctive ID
        wil::unique_prop_variant distinctiveId;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_DISTINCTIVEID, &distinctiveId)) &&
           distinctiveId.vt == VT_UI4)
        {
            configuration.m_distinctiveIdRequirement = static_cast<MF_MEDIAKEYS_REQUIREMENT>(distinctiveId.ulVal);
        }

        // Persistent state
        wil::unique_prop_variant persistentState;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_PERSISTEDSTATE, &persistentState)) &&
           persistentState.vt == VT_UI4)
        {
            configuration.m_persistentStateRequirement = static_cast<MF_MEDIAKEYS_REQUIREMENT>(persistentState.ulVal);
        }

        // Session types
        wil::unique_prop_variant sessionTypes;
        if(SUCCEEDED(propertyStore->GetValue(MF_EME_SESSIONTYPES, &sessionTypes)) &&
           sessionTypes.vt == (VT_VECTOR | VT_UI4))
        {
            configuration.m_sessionTypes = std::vector<MF_MEDIAKEYSESSION_TYPE>(sessionTypes.caul.cElems);
            for(size_t i = 0; i < sessionTypes.caul.cElems; i++)
            {
                configuration.m_sessionTypes[i] = static_cast<MF_MEDIAKEYSESSION_TYPE>(sessionTypes.caul.pElems[i]);
            }
        }

        return configuration;
    }
    wil::com_ptr<IPropertyStore> ConvertToPropertyStore()
    {
        wil::com_ptr<IPropertyStore> propertyStore;
        THROW_IF_FAILED(PSCreateMemoryPropertyStore(IID_PPV_ARGS(propertyStore.put())));

        // Init data types
        auto initDataTypeArray = wil::make_unique_cotaskmem<BSTR[]>(m_initDataTypes.size());
        for(size_t i = 0; i < m_initDataTypes.size(); i++)
        {
            initDataTypeArray[i] = wil::make_bstr(m_initDataTypes[i].c_str()).release();
        }
        wil::unique_prop_variant initDataTypes;
        initDataTypes.vt = VT_VECTOR | VT_BSTR;
        initDataTypes.cabstr.cElems = static_cast<ULONG>(m_initDataTypes.size());
        initDataTypes.cabstr.pElems = initDataTypeArray.release();
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_INITDATATYPES, initDataTypes));

        // Audio capabilities
        wil::unique_prop_variant audioCapabilities = GenerateCapabilityProperty(m_audioCapabilities);
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_AUDIOCAPABILITIES, audioCapabilities));

        // Video capabilities
        wil::unique_prop_variant videoCapabilities = GenerateCapabilityProperty(m_videoCapabilities);
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_VIDEOCAPABILITIES, videoCapabilities));

        // Distinctive ID
        wil::unique_prop_variant distinctiveId;
        distinctiveId.vt = VT_UI4;
        distinctiveId.ulVal = static_cast<DWORD>(m_distinctiveIdRequirement);
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_DISTINCTIVEID, distinctiveId));

        // Persistent state
        wil::unique_prop_variant persistentState;
        persistentState.vt = VT_UI4;
        persistentState.ulVal = static_cast<DWORD>(m_persistentStateRequirement);
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_PERSISTEDSTATE, persistentState));

        // Session types
        auto sessionTypeArray = wil::make_unique_cotaskmem<DWORD[]>(m_sessionTypes.size());
        for(size_t i = 0; i < m_sessionTypes.size(); i++)
        {
            sessionTypeArray[i] = m_sessionTypes[i];
        }
        wil::unique_prop_variant sessionTypes;
        sessionTypes.vt = VT_VECTOR | VT_UI4;
        sessionTypes.caul.cElems = static_cast<ULONG>(m_sessionTypes.size());
        sessionTypes.caul.pElems = sessionTypeArray.release();
        THROW_IF_FAILED(propertyStore->SetValue(MF_EME_SESSIONTYPES, sessionTypes));

        return propertyStore;
    }

    std::wstring m_label;
    std::vector<std::wstring> m_initDataTypes;
    std::vector<MediaKeySystemMediaCapability> m_audioCapabilities;
    std::vector<MediaKeySystemMediaCapability> m_videoCapabilities;
    MF_MEDIAKEYS_REQUIREMENT m_distinctiveIdRequirement;
    MF_MEDIAKEYS_REQUIREMENT m_persistentStateRequirement;
    std::vector<MF_MEDIAKEYSESSION_TYPE> m_sessionTypes;

private:
    static wil::unique_prop_variant GenerateCapabilityProperty(const std::vector<MediaKeySystemMediaCapability>& capabilities)
    {
        auto capabilitiesArray = wil::make_unique_cotaskmem<PROPVARIANT[]>(capabilities.size());
        for(size_t i = 0; i < capabilities.size(); i++)
        {
            auto& Capability = capabilitiesArray[i];
            wil::com_ptr<IPropertyStore> PropertyStore;
            THROW_IF_FAILED(PSCreateMemoryPropertyStore(IID_PPV_ARGS(PropertyStore.put())));
            auto const SetValue = [&](PROPERTYKEY const& Key, std::wstring const& Value)
            {
                wil::unique_prop_variant VariantValue;
                VariantValue.vt = VT_BSTR;
                VariantValue.bstrVal = wil::make_bstr(Value.c_str()).release();
                THROW_IF_FAILED(PropertyStore->SetValue(Key, VariantValue));
            };
            SetValue(MF_EME_ROBUSTNESS, capabilities[i].robustness);
            SetValue(MF_EME_CONTENTTYPE, capabilities[i].contentType);
            Capability.vt = VT_UNKNOWN;
            Capability.punkVal = PropertyStore.query<IUnknown>().detach();
        }
        wil::unique_prop_variant capabilitiesProperty;
        capabilitiesProperty.vt = VT_VECTOR | VT_VARIANT;
        capabilitiesProperty.capropvar.cElems = static_cast<ULONG>(capabilities.size());
        capabilitiesProperty.capropvar.pElems = capabilitiesArray.release();
        return capabilitiesProperty;
    }
    static void GetCapabilitiesFromPropVar(const PROPVARIANT& capabilitiesProperty, std::vector<MediaKeySystemMediaCapability>& capabilities)
    {
        capabilities = std::vector<MediaKeySystemMediaCapability>(capabilitiesProperty.capropvar.cElems);
        for(size_t i = 0; i < capabilities.size(); i++)
        {
            PROPVARIANT& capabilityProperty = capabilitiesProperty.capropvar.pElems[i];
            wil::com_ptr<IPropertyStore> capabilityPropertyStore;
            if(capabilityProperty.vt != VT_UNKNOWN || FAILED(capabilityProperty.punkVal->QueryInterface(IID_PPV_ARGS(capabilityPropertyStore.put()))))
                continue;
            wil::unique_prop_variant robustness;
            if(SUCCEEDED(capabilityPropertyStore->GetValue(MF_EME_ROBUSTNESS, &robustness)) && robustness.vt == VT_BSTR)
                capabilities[i].robustness = std::wstring(robustness.bstrVal);
            wil::unique_prop_variant contentType;
            if(SUCCEEDED(capabilityPropertyStore->GetValue(MF_EME_CONTENTTYPE, &contentType)) && contentType.vt == VT_BSTR)
                capabilities[i].contentType = std::wstring(contentType.bstrVal);
        }
    }
};

// Based on the MediaKeySystemAccess interface in the EME specification:
// https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#mediakeysystemaccess-interface
class MediaKeySystemAccess
{
public:
    MediaKeySystemAccess(EmeFactoryConfiguration& cdmConfigProperties, wil::com_ptr<IMFContentDecryptionModuleAccess> const& cdmAccess) :
        m_cdmAccess(cdmAccess)
    {
        m_cdmProperties = cdmConfigProperties.ConvertToPropertyStore();
        wil::com_ptr<IPropertyStore> PropertyStore;
        THROW_IF_FAILED(cdmAccess->GetConfiguration(PropertyStore.put()));
        m_keySystemConfiguration = MediaKeySystemConfiguration::FromPropertyStore(PropertyStore);
    }

    wil::unique_cotaskmem_string keySystem() const
    {
        wil::unique_cotaskmem_string keySystem;
        THROW_IF_FAILED(m_cdmAccess->GetKeySystem(keySystem.put()));
        return keySystem;
    }
    const MediaKeySystemConfiguration& getConfiguration() const
    {
        return m_keySystemConfiguration;
    }
    std::shared_ptr<MediaKeys> createMediaKeys() const
    {
        wil::com_ptr<IMFContentDecryptionModule> ContentDecryptionModule;
        TRACE(L"Before IMFContentDecryptionModuleAccess::CreateContentDecryptionModule, this %p\n", this);
        THROW_IF_FAILED(m_cdmAccess->CreateContentDecryptionModule(m_cdmProperties.get(), ContentDecryptionModule.put()));
        TRACE(L"this %p, IMFContentDecryptionModule cdm %p\n", this, ContentDecryptionModule.get());
        return std::make_shared<MediaKeys>(ContentDecryptionModule.get());
    }

private:
    wil::com_ptr<IPropertyStore> m_cdmProperties;
    wil::com_ptr<IMFContentDecryptionModuleAccess> m_cdmAccess;
    MediaKeySystemConfiguration m_keySystemConfiguration;
};

// Class used to query for EME keysystem support and attempt creation of a MediaKeySystemAccess object for a specified keysystem
class EmeFactory
{
public:
    EmeFactory(EmeFactoryConfiguration cdmConfigProperties)
    {
        TRACE(L"this %p\n", this);
        THROW_IF_FAILED(CoCreateInstance(CLSID_MFMediaEngineClassFactory, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(m_classFactory.put())));
        m_cdmConfigProperties = cdmConfigProperties;
    }
    virtual ~EmeFactory() = default;

    // Used to request creation of a MediaKeySystemAccess. Based on:
    // https://www.w3.org/TR/2017/REC-encrypted-media-20170918/#dom-navigator-requestmediakeysystemaccess
    // Returns: MediaKeySystemAccess on success, or nullptr if the keysystem or none of the specified configurations are supported
    std::shared_ptr<MediaKeySystemAccess> requestMediaKeySystemAccess(const std::wstring& keySystem, std::vector<MediaKeySystemConfiguration>& configurations)
    {
        TRACE(L"this %p, keySystem %ls, configurations.size() %zu\n", this, keySystem.c_str(), configurations.size());

        // Use a cached CDM factory if client is querying for the same keysystem, otherwise create a new CDM factory
        if(!m_cdmFactory || m_cachedFactoryKeySystem != keySystem)
        {
            TRACE(L"Before IMFMediaEngineClassFactory4::CreateContentDecryptionModuleFactory, this %p\n", this);
            if(FAILED(LOG_IF_FAILED(m_classFactory->CreateContentDecryptionModuleFactory(keySystem.c_str(), IID_PPV_ARGS(m_cdmFactory.put())))))
                return nullptr;
            TRACE(L"this %p, IMFContentDecryptionModuleFactory m_cdmFactory %p\n", this, m_cdmFactory.get());
            m_cachedFactoryKeySystem = keySystem;
        }

        if(!m_cdmFactory->IsTypeSupported(keySystem.c_str(), nullptr))
            return nullptr;
        wil::com_ptr<IMFContentDecryptionModuleAccess> ContentDecryptionModuleAccess;
        std::vector<wil::com_ptr_t<IPropertyStore>> configurationPropertyStores;
        for(auto& config : configurations)
        {
            wil::com_ptr_t<IPropertyStore> propStore;
            propStore.attach(config.ConvertToPropertyStore().detach());
            configurationPropertyStores.push_back(propStore);
        }
        if(FAILED(LOG_IF_FAILED(m_cdmFactory->CreateContentDecryptionModuleAccess(keySystem.c_str(), configurationPropertyStores[0].addressof(), static_cast<DWORD>(configurationPropertyStores.size()), ContentDecryptionModuleAccess.put()))))
            return nullptr;
    
        return std::make_shared<MediaKeySystemAccess>(m_cdmConfigProperties, ContentDecryptionModuleAccess.get());
    }

private:
    EmeFactoryConfiguration m_cdmConfigProperties;
    wil::com_ptr<IMFMediaEngineClassFactory4> m_classFactory;
    wil::com_ptr<IMFContentDecryptionModuleFactory> m_cdmFactory;
    std::wstring m_cachedFactoryKeySystem;
};

} // namespace eme

// A custom MF media source wrapper which supports protected playback using a provided ContentDecryptionModule
// Demuxing is performed by the inner source provided by the application
class InputTrustAuthorityMediaSource : public winrt::implements<InputTrustAuthorityMediaSource, IMFMediaSource, IMFTrustedInput>
{
public:
    InputTrustAuthorityMediaSource(std::shared_ptr<eme::MediaKeys> mediaKeys, wil::com_ptr<IMFMediaSource> const& MediaSource) :
        m_Inner(MediaSource),
        m_ContentDecryptionModule(mediaKeys->m_ContentDecryptionModule)
    {
        WI_ASSERT(m_Inner && m_ContentDecryptionModule);
    }

// IMFMediaSource
    IFACEMETHOD(GetCharacteristics)(DWORD* characteristics) noexcept override
    {
        //TRACE(L"this %p\n", this);
        return m_Inner->GetCharacteristics(characteristics);
    }
    IFACEMETHOD(CreatePresentationDescriptor)(IMFPresentationDescriptor** presentationDescriptorOut) noexcept override
    {
        //TRACE(L"this %p\n", this);
        return m_Inner->CreatePresentationDescriptor(presentationDescriptorOut);
    }
    IFACEMETHOD(Start)(IMFPresentationDescriptor* PresentationDescriptor, GUID const* TimeFormat, PROPVARIANT const* StartPosition) noexcept override
    {
        TRACE(L"this %p\n", this);
        return m_Inner->Start(PresentationDescriptor, TimeFormat, StartPosition);
    }
    IFACEMETHOD(Stop)() noexcept override
    {
        TRACE(L"this %p\n", this);
        return m_Inner->Stop();
    }
    IFACEMETHOD(Pause)() noexcept override
    {
        TRACE(L"this %p\n", this);
        return m_Inner->Pause();
    }
    IFACEMETHOD(Shutdown)() noexcept override
    {
        TRACE(L"this %p\n", this);
        {
            [[maybe_unused]] auto&& DataLock = m_DataMutex.lock_exclusive();
            m_StreamTrustedInputMap.clear();
        }
        return m_Inner->Shutdown();    
    }

// IMFMediaEventGenerator
    IFACEMETHOD(GetEvent)(DWORD flags, IMFMediaEvent** eventOut) noexcept override
    { 
        //TRACE(L"this %p\n", this);
        return m_Inner->GetEvent(flags, eventOut);
    }
    IFACEMETHOD(BeginGetEvent)(IMFAsyncCallback* callback, IUnknown* state) noexcept override
    {
        //TRACE(L"this %p\n", this);
        return m_Inner->BeginGetEvent(callback, state);
    }
    IFACEMETHOD(EndGetEvent)(IMFAsyncResult* result, IMFMediaEvent** eventOut) noexcept override
    { 
        //TRACE(L"this %p\n", this);
        return m_Inner->EndGetEvent(result, eventOut);
    }
    IFACEMETHOD(QueueEvent)(MediaEventType type, REFGUID extendedType, HRESULT status, const PROPVARIANT* value) noexcept override
    { 
        //TRACE(L"this %p\n", this);
        return m_Inner->QueueEvent(type, extendedType, status, value);
    }

// IMFTrustedInput
    IFACEMETHOD(GetInputTrustAuthority)(DWORD StreamIdentifier, REFIID InterfaceIdentifier, IUnknown** Object) noexcept override
    {
        TRACE(L"this %p, StreamIdentifier %u, InterfaceIdentifier %ls\n", this, StreamIdentifier, ToString(InterfaceIdentifier).c_str());
        try
        {
            LOG_HR_IF(S_FALSE, InterfaceIdentifier != __uuidof(IMFInputTrustAuthority));
            WI_ASSERT(Object);
            wil::com_ptr<IUnknown> Unknown;
            [[maybe_unused]] auto&& DataLock = m_DataMutex.lock_exclusive();
            auto const Iterator = m_StreamTrustedInputMap.find(StreamIdentifier);
            if(Iterator == m_StreamTrustedInputMap.end())
            {
                if(!m_TrustedInput)
                    THROW_IF_FAILED(m_ContentDecryptionModule->CreateTrustedInput(nullptr, 0, m_TrustedInput.put()));
                THROW_IF_FAILED(m_TrustedInput->GetInputTrustAuthority(StreamIdentifier, InterfaceIdentifier, Unknown.put()));
                m_StreamTrustedInputMap[StreamIdentifier] = Unknown;
            } else
                Unknown = Iterator->second;
            *Object = Unknown.detach();
        }
        CATCH_RETURN();
        return S_OK;
    }

private:
    wil::com_ptr<IMFContentDecryptionModule> const m_ContentDecryptionModule;
    wil::com_ptr<IMFMediaSource> const m_Inner;
    mutable wil::srwlock m_DataMutex;
    wil::com_ptr<IMFTrustedInput> m_TrustedInput;
    std::map<DWORD, wil::com_ptr<IUnknown>> m_StreamTrustedInputMap;
};

} // namespace media
